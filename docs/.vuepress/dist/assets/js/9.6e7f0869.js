(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{364:function(e,n,s){"use strict";s.r(n);var t=s(42),o=Object(t.a)({},(function(){var e=this,n=e.$createElement,s=e._self._c||n;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"前端开发必不可少-什么是异步编程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前端开发必不可少-什么是异步编程"}},[e._v("#")]),e._v(" 前端开发必不可少，什么是异步编程")]),e._v(" "),s("p",[e._v("由于 javascript 语言是一门“单线程”的语言，所以，javascript 就像一条流水线，仅仅是一条流水线而已，要么加工，要么包装，不能同时进行多个任务和流程。")]),e._v(" "),s("p",[e._v("而作为前端开发，在面试与工作中相信大家一定被问过或经常需要用到异步编程，那么什么是异步编程呢？")]),e._v(" "),s("p",[e._v("首先我们先区分一下什么是同步编程，什么是异步编程。")]),e._v(" "),s("p",[e._v("同步编程：我们都知道代码的执行顺序是自上而下执行的，那么同步就是需要每一个任务都完成以后再去执行下一个任务，执行顺序与排列顺序是一致的。坏处，只要有一个任务耗时很长，后面任务都必须排队等着，常见的浏览器无响应，死循环。")]),e._v(" "),s("p",[e._v("异步编程：每一个任务有一个或多个回调函数，前一个任务执行完后，不是执行下一个任务，而是执行回调函数，后一个任务是不等前一个任务结束就执行的，所以程序的执行顺序与任务的排列顺序是不一致的。")]),e._v(" "),s("p",[e._v("简单的说我们可以将异步编程理解为在约定的时间内完成的操作。")]),e._v(" "),s("p",[e._v("举个简单的例子：\n假设你设置了一个第二天 7:00 的闹钟，那么我们设置完，是一直在等待闹钟的提醒，再去做下一件事，还是去做别的事情，相信大家都不会傻傻的在那等，在编程里这就异步编程。")]),e._v(" "),s("p",[e._v("异步编程怎么判断：是否阻塞 ? 同步阻塞 ，异步不阻塞。")]),e._v(" "),s("p",[e._v("那么常见的异步编程有什么呢？")]),e._v(" "),s("ul",[s("li",[e._v("setTimeout")]),e._v(" "),s("li",[e._v("Ajax")]),e._v(" "),s("li",[e._v("Promise")]),e._v(" "),s("li",[e._v("async 函数")])]),e._v(" "),s("p",[e._v("接下来我们通过代码看看异步编程是如何执行的")]),e._v(" "),s("h4",{attrs:{id:"定时器-settimeout"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#定时器-settimeout"}},[e._v("#")]),e._v(" 定时器(setTimeOut)")]),e._v(" "),s("p",[e._v("在规定的时间内完成操作： 点击按钮，会打印“我先执行” 接着打印 “执行定时器”。 可以看到虽然时间设置为 0，但是定时器里的任务并不是先被执行")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("<body>\n    <button>点击触发定时器</button>\n    <script>\n        let btn = document.querySelector('button');\n        btn.onclick = function () {\n            setTimeout(function () {\n                alert('执行定时器');\n            }, 0)\n\n        }\n        console.log('我先执行');\n    <\/script>\n</body>\n")])])]),s("p",[s("img",{attrs:{src:"https://note.youdao.com/favicon.ico",alt:"setTimeout"}})]),e._v(" "),s("h4",{attrs:{id:"ajax-异步-javascript-和-xml"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ajax-异步-javascript-和-xml"}},[e._v("#")]),e._v(" Ajax (异步 JavaScript 和 XML)")]),e._v(" "),s("p",[e._v("首先介绍我们先一下 Ajax。")]),e._v(" "),s("p",[e._v("AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）")]),e._v(" "),s("p",[e._v("Ajax 是一种无需重新加载整个页面的情况下，能够更新部分网页的技术。")]),e._v(" "),s("p",[e._v("接着我们通过一个简单的例子来看看 ajax 的强大(为了方便调用接口我们直接使用网上链接https://cnodejs.org/api)，为了观看效果明显一些会使用点击事件让大家看看触发结果")]),e._v(" "),s("p",[e._v("Ajax 现代浏览器均支持 XMLHTTPRequest 对象，但是 IE5、IE6 需要兼容，下面就不做兼容处理了")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("<body>\n    <button onclick=\"loadXML()\">点击获取结果</button>\n    <div></div>\n    <script>\n\n        function loadXML() {\n            let xmlhttp = new XMLHttpRequest();\n            xmlhttp.onreadystatechange = function () {\n                if (xmlhttp.readyState == 4 && xmlhttp.status == 200) {\n                    console.log(xmlhttp)\n                    document.querySelector('div').innerHTML = JSON.parse(xmlhttp.responseText).data[0].content;\n                }\n            }\n            xmlhttp.open('GET', 'https://cnodejs.org/api/v1/topics', true)\n            xmlhttp.send()\n            console.log('我先执行了')\n        }\n    <\/script>\n\n</body>\n\n")])])]),s("p",[e._v("可以看得到结果依然是先打印了后面的“我先执行了”")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://note.youdao.com/favicon.ico",alt:"Ajax"}})]),e._v(" "),s("h4",{attrs:{id:"promise-对象"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#promise-对象"}},[e._v("#")]),e._v(" Promise 对象")]),e._v(" "),s("p",[e._v("什么是 promise 对象 ：")]),e._v(" "),s("p",[e._v("从英文翻译来讲就是”承诺“，既然是承诺肯定就需要去完成嘛，所以还是对应了上面说的 ，异步编程可以理解为在约定的时间内完成的操作。")]),e._v(" "),s("p",[e._v("promise 有三种状态：pendding ，fulfilled，rejected")]),e._v(" "),s("ul",[s("li",[e._v("pendding： 初始状态，不成功，不失败，")]),e._v(" "),s("li",[e._v("fulfilled：操作成功")]),e._v(" "),s("li",[e._v("rejected：操作失败")])]),e._v(" "),s("p",[e._v("当 promise 状态发生改变，就会触发 then()里的响应函数处理后续步骤；当 promise 状态一经改变，不会再变。")]),e._v(" "),s("p",[e._v("promise 的使用")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("setTimeout(() => console.log(1), 0); // 异步\nconst p = new Promise((resolve, reject) => {\n    console.log(2);                 // 同步\n    setTimeout(() => {\n        console.log(4)               // 异步优先级低于promise\n    }, 0)\n    resolve(3);\n    console.log(5);                 // 同步\n})\nconsole.log(6)                      // 同步\np.then(value => {\n    console.log(value);             // 异步\n})\n\nconsole.log(7)                      // 同步\n")])])]),s("p",[e._v("上面这一段代码其实在面试中很常见\n执行结果是 2 5 6 7 3 1 4")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://note.youdao.com/favicon.ico",alt:"Promise1"}})]),e._v(" "),s("p",[e._v("再讲结果之前我们应该了解一下 es6 的新增的任务队列 是在事件循环之上的（onclick, setTimeout,Ajax）")]),e._v(" "),s("ul",[s("li",[e._v("onclick 是浏览器内核的 DOM Binding 模块来处理的，当事件触发的时候，回调函数会立即添加到任务队列中。")]),e._v(" "),s("li",[e._v("setTimeout 是浏览器内核的 timer 模块进行的延时处理，当时间到达后才会回调添加到任务队列中。")]),e._v(" "),s("li",[e._v("Ajax 是浏览器内核 network 模块在网络请求完成之后，将回调添加到任务队列中。")])]),e._v(" "),s("p",[e._v("代码也写了，结果也看了，但是我们为什么要用 promise 呢？")]),e._v(" "),s("p",[e._v("常见的回答都是解决回调地狱，其实 promise 也是用于解决异步编程的，\n在 promise 未出现前，我们的异步编程都是通过纯回调解决的")]),e._v(" "),s("p",[e._v("举个例子")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// 纯回调\nfunction createdAsync(value,success,catch){\n    if (value){\n        success()\n    }else{\n        catch()\n    }\n}\nconst success = function (){\n    console.log('成功')\n}\nconst catch = catch(){\n    console.log('失败')\n}\n\ncreatedAsync(value,success,catch)\n\n\n// promise\nconst promise = createdAsync(value);\nsetTimeout(()=>{\n    promise.then(success,catch);\n},1000);\n\n")])])]),s("p",[e._v("可以看得出 纯回调的形式是先指定回调函数，在我们想要启动异步任务前就必须指定好成功、失败的回调函数，而且我们不能在它完成后在指定回调函数，等他执行完毕已经获取不到数据了；\n而 promise 是通过执行一个函数，这个函数返回一个 promise 对象，异步操作是在这个 Promise 对象内部进行的，也就是 Promise 构造函数执行时立即调用 executor 函数，此时异步任务开始了，但是并不需要指定成功、失败的回调函数。")]),e._v(" "),s("p",[e._v("可以再在来看看前面的代码（我们将代码写的简短一些）")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('const p = new Promise((resolve, reject) => {\n    console.log("executor执行器函数"); //  executor执行器函数\n    // 异步任务\n    resolve("异步")\n})\np.then(value => {\n    console.log(value);\n})\nconsole.log("new Promise 之后")\n')])])]),s("p",[e._v("打印结果是： ”executor 执行器函数“ 、”new Promise 之后“ 、“异步”")]),e._v(" "),s("p",[s("img",{attrs:{src:"https://note.youdao.com/favicon.ico",alt:"Promise2"}})]),e._v(" "),s("p",[e._v("所以 promsie 其实不只是解决回调地狱问题，而说到了回调地狱，其实 async 函数显得更加优化。")]),e._v(" "),s("h4",{attrs:{id:"async-函数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#async-函数"}},[e._v("#")]),e._v(" Async 函数")]),e._v(" "),s("p",[e._v("什么是 async 函数")]),e._v(" "),s("p",[e._v("ES2017 标准引入了 async 函数，使得异步操作变得更加方便。\nasync 函数是什么？一句话，它就是 Generator 函数的语法糖。")]),e._v(" "),s("p",[e._v("但是我更加倾向于 async 函数是 Promise 语法糖。我们通过下面的例子看看。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v(" // 以往定义promise的时候\n  new Promise((resolve,reject)=>{\n    console.log('开始');\n    resolve('异步');\n  }).then(value => {console.log(value)})\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// async函数\n  async function fn(){}\n  console.log(fn())  // Promise{<fulfilled>:undefined}\n")])])]),s("p",[e._v("可以看得出 async 的返回值就是一个 Promise 对象 并且默认返回一个执行结果为成功的 Promise 对象，也就是 new Promise() 的语法糖")]),e._v(" "),s("p",[e._v("接着我们看看 async 下的 await")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// promise\nconst promise = new Promise((resolve, reject) => {\n    resolve('异步');\n})\n\npromise.then(value => {\n    console.log(value)\n})\n\n// async\nasync function fn(callback) {\n    const val = await callback;\n    console.log(val)\n}\n\nfn(promise)\n}\n")])])]),s("p",[e._v("可以看得出 await 就是 then 的语法糖")]),e._v(" "),s("p",[e._v("接着我们看看这个语法糖为我们解决了什么问题")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("// promise\nnew Promise((resolve, reject) => {\n    resolve(1);\n}).then(value => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(value + 1)\n        })\n    });\n}).then(value => {\n    return new Promise((resolve, reject) => {\n        setTimeout(() => {\n            resolve(value + 1)\n        })\n    });\n}).then(value => {\n    console.log(value + 1)\n})\nconsole.log('我先')\n\n// ascyn\n\nasync function fn() {\n    const one = await new Promise((resolve, reject) => {\n        resolve(1)\n    })\n    const two = await new Promise((resolve, reject) => {\n        resolve(one + 1)\n    })\n    console.log(two);\n    console.log('我先')\n}\n\nfn()\n")])])]),s("p",[e._v("可以看得出 promise 的执行会 先打印出 “我先”，而 asyn 函数 会将异步执行完毕再进行下面的操作，所以 async 函数不仅实现了异步编程，并且在代码的上来说执行顺序与排列顺序是一致的。")]),e._v(" "),s("p",[e._v("文中说的内容偏入门级别，也是结合自己所学以及理解。\n最后想说的是随着前端开发的不断发展，前端开发人员掌握的技术已经不再是之前的 html+css 了（俗称的切图仔），并且前端开发人员需要掌握的技术不亚于后端了，甚至需要掌握一些后端知识。")])])}),[],!1,null,null,null);n.default=o.exports}}]);